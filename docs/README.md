# Полное руководство по формату Valve Map Format (VMF)

Это руководство объясняет формат `.vmf`, который используется Hammer Editor и многими другими инструментами Valve для описания уровней Source Engine. Постарайтесь воспринимать текст как подробный рассказ для начинающего, поэтому здесь много конкретики, примеров и пояснений «почему так».

## 1. Что такое VMF и зачем он нужен

`VMF` (Valve Map Format) — это текстовый формат на основе ключ-значение, в котором описываются **все** элементы карты: от мирового пространства и освещения до позиционирования реквизита. Hammer сохраняет проект карты в `.vmf`; на стадии сборки (`vbsp`, `vvis`, `vrad`) этот файл преобразуется в бинарный `.bsp`.

### Основные свойства VMF

* **Читаемый текст** — любой текстовый редактор покажет структуру файла.
* **Иерархия** — всё оформлено в виде вложенных блоков `{ ... }`, напоминающих JSON или XML.
* **Версионирование** — в заголовке хранятся версии формата и требуемого редактора.
* **Координатные единицы** — используются «юниты» Source, где 1 юнит ≈ 1.9 см (зависит от игры, но принято считать ~1 дюйм).

## 2. Общая структура файла

Пример каркаса файла:

```
versioninfo
{
    "editorversion" "400"
    "mapversion" "23"
}

visgroups
{
    // Описания групп видимости
}

viewsettings { ... }
world { ... }
entity { ... }
entity { ... }
```

Каждый раздел отвечает за собственный аспект:

| Раздел          | Назначение |
|-----------------|------------|
| `versioninfo`   | Версии формата и редактора.
| `visgroups`     | Пользовательские группы для скрытия/показа объектов.
| `viewsettings`  | Параметры вида (где камера, сетка и т. п.).
| `world`         | Корневой «мир» — базовые кисти и параметры карты.
| `entity`        | Дополнительные сущности (свет, реквизит, логика и пр.).
| `cordon`        | (опционально) ограждающий прямоугольник для частичной компиляции.

## 3. Формат ключ-значение

Каждый блок состоит из строк вида `"ключ" "значение"`. Ключи и значения **всегда** в кавычках. Пробелы внутри значений разрешены. Пример:

```
"classname" "light"
"origin" "0 128 64"
```

Hammer сохраняет координаты как три числа через пробел в порядке `X Y Z`. Оси устроены так:

* `X` — вправо (восток),
* `Y` — вперёд (север),
* `Z` — вверх.

## 4. Раздел `versioninfo`

Этот блок сообщает инструментам, какая версия редактора создала файл.

```
versioninfo
{
    "editorversion" "400"
    "editorbuild" "8001"
    "mapversion" "23"
    "formatversion" "100"
    "prefab" "0"
}
```

* `editorversion` и `editorbuild` нужны Hammer, чтобы предупредить о несовместимостях.
* `mapversion` увеличивается при каждом сохранении.
* `formatversion` — версия формата VMF (обычно 100).
* `prefab` показывает, является ли файл заготовкой (0 — обычная карта).

## 5. Раздел `visgroups`

Visgroup — это пользовательская «папка» для логической группировки объектов. В блоке перечислены группы и их цвет.

```
visgroups
{
    visgroup
    {
        "name" "Lighting"
        "visgroupid" "1"
        "color" "255 255 0"
    }
}
```

* `visgroupid` — уникальный идентификатор, который привязывается к объектам.
* У объектов в их блоках может появляться строка `"visgroupid" "1"`.
* Вложенные visgroup'ы поддерживаются: внутри `visgroup { ... }` можно создавать другие блоки `visgroup`.

## 6. Раздел `viewsettings`

Хранит настройки Hammer: активный 2D-вид, цвет сетки, включённые фильтры. Это влияет только на редактор.

Пример ключей:

* `"bSnapToGrid" "1"` — привязка к сетке.
* `"nGridSpacing" "64"` — текущий шаг сетки.
* `"bShowGrid" "1"` — отображать сетку.
* `"bShowLogicalGrid" "0"` — показывать логическую сетку.

Раздел важен, если вы хотите, чтобы коллеги видели карту «так же» при открытии.

## 7. Раздел `world` — сердце VMF

Блок `world` представляет статическую геометрию и базовые параметры.

### 7.1 Заголовок `world`

```
world
{
    "id" "1"
    "mapversion" "23"
    "classname" "worldspawn"
    "skyname" "sky_day01_01"
    "maxpropscreenwidth" "-1"
    "startdark" "0"
    ...
}
```

* `classname` всегда `worldspawn`.
* `skyname` задаёт небо.
* Прочие ключи: `lightmapscale`, `maxpropscreenwidth`, `detailmaterial`, `detailvbsp`.
* `lightmapscale` на уровне `worldspawn` задаёт значение по умолчанию для новых граней (обычно 16).
* `detailmaterial` и `detailvbsp` указывают, где искать шаблоны для автоматического рассаживания растительности.
* `maxpropscreenwidth` контролирует автоскрытие крупных `prop` при далёком расстоянии (значение `-1` = отключено).
* `startdark`, `gametitle`, `commentaryfile` и похожие строки включают режимы кампаний (например, комментарии разработчиков).

### 7.2 Кисти (brushes)

Кисть — базовый строительный блок карты. Внутри `world` каждая кисть хранится в блоке `solid`:

```
solid
{
    "id" "2"
    side { ... }
    side { ... }
    side { ... }
    side { ... }
    side { ... }
    side { ... }
    editor { ... }
}
```

#### Важные моменты про кисти

* Кисть — **выпуклый** объём. Вогнутые формы создаются набором выпуклых кистей.
* Количество `side` определяет форму (куб — 6, призма — 5 и т. д.).
* Hammer автоматически ограничивает кисти размером до 1024–4096 юнитов в зависимости от игры.

### 7.3 Стороны кисти (`side`)

Каждая грань описывается блоком `side`:

```
side
{
    "id" "12"
    "plane" "(0 0 0) (0 128 0) (0 128 128)"
    "material" "BRICK/WALL_01"
    "uaxis" "[1 0 0 0] 0.25"
    "vaxis" "[0 0 -1 0] 0.25"
    "rotation" "0"
    "lightmapscale" "16"
    "smoothing_groups" "0"
}
```

Разберём каждое поле:

* `plane` — три точки в 3D (в порядке против часовой стрелки, если смотреть снаружи). Они определяют бесконечную плоскость, из пересечения нескольких плоскостей формируется объём кисти.
* `material` — путь к текстуре (VMT) без расширения.
* `uaxis` и `vaxis` описывают, как текстура натягивается: `[x y z offset] scale`. Hammer использует локальные оси для UV-карт.
* `rotation` — дополнительный поворот текстуры.
* `lightmapscale` — разрешение лайтмапа (меньше число → лучше качество, но дороже).
* `smoothing_groups` — влияет на сглаживание при рендере моделей (обычно 0).

#### Как формируется объём

1. Для каждой грани берётся плоскость.
2. Пересечение плоскостей превращает бесконечные полупространства в замкнутый объём.
3. Если плоскости образуют выпуклую область, компилятор строит из них полигоны.
4. Если грани заданы неправильно (например, плоскости не пересекаются должным образом), компилятор выдаст ошибку (`solid with nonplanar face`).

### 7.4 Подраздел `editor`

Внутри `solid` и `side` часто есть блок `editor`, который хранит свойства, нужные только Hammer: цвет выделения, ID группы, скрытость.

```
editor
{
    "color" "0 255 0"
    "visgroupid" "1"
    "groupid" "-1"
    "snapid" "0"
}
```

* `color` — цвет кисти в 2D виде.
* `groupid` связывает кисть с `group { ... }` (см. ниже).
* `visgroupid` привязывает к visgroup.
* Дополнительно Hammer может писать `"visgroupautoshown" "1"` (отвечает за автопоказ при включении группы).
* `snapid` нужен для инструмента Vertex Tool: вершины с одинаковым `snapid` «приклеены» и двигаются вместе.
* В сложных сценах встречается `"logicalpos" "[x y]"` — координата в Logic Editor Hammer.

#### Отображение скрытых кистей

Если объект скрыт, Hammer добавляет в `editor` ключ `"hidden" "1"`. Удалите или поменяйте на `0`, чтобы вернуть его в сцену.

### 7.5 Displacements

Для гибких поверхностей, таких как Terrain, используется блок `dispinfo`, вложенный в `side`:

```
dispinfo
{
    "power" "3"
    "startposition" "[0 0 128]"
    "elevation" "0"
    "subdiv" "0"
    normals { ... }
    distances { ... }
    offsets { ... }
    alphas { ... }
    triangle_tags { ... }
    allowed_verts { ... }
}
```

* `power` определяет плотность сетки: 2 → 4×4, 3 → 8×8, 4 → 16×16.
* `startposition` — позиция угла исходной плоскости.
* `normals`, `distances`, `offsets`, `alphas` — массивы чисел для каждой вершины.
* `triangle_tags` управляет швами, `allowed_verts` — какие вершины можно редактировать.

Дисплейс наследует материал от грани, к которой привязан.

## 8. Раздел `entity` — логика и динамика

Каждая сущность (`light`, `prop_static`, `trigger_multiple`) описывается блоком `entity` на верхнем уровне (вне `world`). Структура похожа:

```
entity
{
    "id" "100"
    "classname" "light"
    "origin" "256 64 128"
    "pitch" "-45"
    "angles" "0 180 0"
    "_light" "255 255 128 200"
    connections
    {
        "OnUser1" "door,Open,,0,-1"
    }
    editor { ... }
}
```

### Ключевые поля

* `id` — уникальный номер.
* `classname` — тип сущности (сопровождается набором ключей из FGD-файла игры).
* `origin` — позиция в мире.
* `angles` — Эйлеровы углы `pitch yaw roll` в градусах (по умолчанию `0 0 0`).
* Специфические ключи (`_light`, `model`, `targetname` и т. д.) зависят от класса.
* `connections` (ранее `outputs`) хранит входы/выходы I/O системы Source.
* `spawnflags` объединяет набор булевых флагов для поведения (число = сумма битов из FGD).
* `rendercolor`, `renderamt`, `rendermode` управляют визуализацией для многих сущностей.

#### Формат блока `connections`

Каждая строка описывает один выход: `"ИмяВыхода" "цель,вход,параметр,задержка,кол-во"`.

* `цель` — `targetname` получателя. Можно перечислять несколько через `;`.
* `вход` — имя входного сигнала (например, `Open`, `Kill`, `Enable`).
* `параметр` — дополнительное значение, иногда пустое.
* `задержка` — число секунд перед выполнением (может быть дробным).
* `кол-во` — сколько раз срабатывать (`-1` = бесконечно).

### Brush entities

Если кисть должна вести себя как сущность (например, `func_door`), структура выглядит так:

```
entity
{
    "classname" "func_door"
    solid { ... }
    solid { ... }
    editor { ... }
}
```

* Внутри сущности располагается блок `solid`, аналогичный `world`.
* Такая сущность называется **brush entity**.
* `origin` задаётся либо явно, либо через отдельную `func_door`-origin brush.
* Внутри блока `entity` можно встретить `connections` и другие ключи, как у обычных точечных сущностей.

#### Центр вращения и `origin`

Для сущностей вроде `func_door_rotating` Hammer автоматически создаёт вспомогательный `solid` с материалом `tools/toolorigin`. Его координаты определяют pivot. В VMF этот `solid` помечается `"editor" { "is_solid" "0" }`.

## 9. Группы (`group`)

Hammer позволяет объединять объекты в группы. В VMF группа описывается блоком `group` внутри `world` или `entity`:

```
group
{
    "id" "5"
    editor { "groupcolor" "255 0 0" }
    solid { ... }
    entity { ... }
}
```

Но на практике Hammer чаще добавляет только ссылку `"groupid"` внутри `editor` каждого объекта, а отдельного блока `group` может и не быть.

* Чтобы «разгруппировать» объекты вручную, установите `groupid` в `-1` у каждого участника.
* Hammer использует положительные `groupid` для связки объектов. Старайтесь не дублировать ID.

## 10. Cordon

Блок `cordon` содержит данные о прямоугольном объёме, внутри которого компилируется часть карты:

```
cordon
{
    "mins" "-512 -512 -128"
    "maxs" "512 512 256"
    "active" "0"
}
```

* `mins` и `maxs` задают противоположные углы параллелепипеда.
* `active` = 1 включает режим cordon при компиляции.

## 11. Как Hammer создаёт кисть: пошагово

1. **Выбор плоскостей** — пользователь рисует 2D прямоугольник, Hammer extrude'ит его в 3D.
2. **Назначение материала** — по умолчанию `tools/toolstrigger` или `tools/toolsskybox` в зависимости от типа.
3. **Запись в VMF** — Hammer присваивает `id`, создаёт нужное число `side`.
4. **Добавление в `world` или `entity`** — в зависимости от выбранного класса.

Если пользователь редактирует вершины, Hammer перерасчитывает `plane` для соответствующей стороны.

## 12. Текстуры и UV-координаты

* `uaxis` и `vaxis` имеют формат `[ux uy uz offset] scale`.
* `offset` смещает текстуру, а `scale` растягивает/сжимает (обычно 0.25 = текстура по умолчанию, т.к. Source работает в шагах 0.25 юнита per texel).
* Поворот задаётся отдельно `"rotation"`.
* Hammer хранит эти значения независимо от реального размера текстуры, компилятор пересчитает UV при экспорте.
* Если у материала указана `RotationFix`, Hammer корректирует смещение при повороте, чтобы рисунок не «сползал».
* Для выравнивания по мировым осям используйте `Face Edit Sheet` → `Align to World`; в VMF это приводит к изменению `uaxis`/`vaxis`.

## 13. Детальные пропы (`detail`)

В `worldspawn` есть ссылки на файлы `detail.vbsp` и `detail.material`. Они используются для автоматической генерации мелкой растительности (`func_detail`, `detail sprites`). VMF хранит только путь; компилятор `vbsp` подставляет модели из этих файлов во время сборки.

## 14. Обрезка (`clipping`) и carve

* **Clipping Tool** — Hammer делит кисть, создавая две новых `solid` с пересчитанными гранями.
* **Carve** — опасный инструмент: вычитает объём одной кисти из другой, генерируя множество новых граней. В VMF это отражается кучей новых `side` и `solid`. Valve docs рекомендуют избегать `Carve` и вручную строить геометрию.

## 15. Единицы измерения и сетка

* 1 юнит ≈ 1 дюйм (2.54 см). Стандартная высота игрока — ~72 юнита.
* Сетка в Hammer — степени двойки: 1, 2, 4, 8, 16, 32, 64, 128, 256...
* Старайтесь держаться сетки: «off-grid» вершины вызывают микрощели и ошибки компиляции.

## 16. Компиляция: путь VMF → BSP

1. `vbsp` читает VMF, строит плёночные объёмы и конвертирует в бинарный BSP. На этом этапе применяются детали (`func_detail` превращается в отдельные поверхностные объекты), создаются объёмы `leaf`.
2. `vvis` анализирует видимость между `leaf`.
3. `vrad` рассчитывает освещение, используя световые данные из VMF.

Ошибки компиляции (`vbsp` errors) часто указывают на проблемы с кистями (неплоская грань, пересечение `invalid solid`).

## 17. Советы по чтению и редактированию VMF вручную

* **Следите за `id`** — Hammer требует уникальных ID. Если создаёте кисти вручную, увеличивайте `id`.
* **Порядок блоков не критичен**, но удобнее группировать по назначению.
* **Комментарии** — VMF не поддерживает комментарии, всё, что не в кавычках, считается ошибкой.
* **Кодировка** — ANSI или UTF-8 без BOM.
* **Резервные копии** — сохраняйте файл перед массовым поиском/заменой: одна неверная кавычка делает всю карту нечитаемой.
* **Проверяйте `solid` на выпуклость** — если редактируете координаты вручную, контролируйте порядок точек в `plane`.

## 18. Часто встречающиеся сущности и их ключи

### `light`

* `"_light" "R G B яркость"`
* `"style"` — шаблон мерцания.

### `light_spot`

* Дополнительно `"pitch"` и `"angles"`.
* Имеет дочернюю `info_target` для указания направления (если выставить `IsSpotlight` = true).

### `prop_static`

* `"model" "models/props/...mdl"`
* `"disablevertexlighting"` управляет покраской вершин.
* Не двигается, используется для реквизита.

### `trigger_multiple`

* Создаётся как brush entity с материалом `tools/toolstrigger`.
* Имеет ключи `"spawnflags"`, `"wait"`, и I/O события `OnStartTouch`, `OnEndTouch`.
* Для фильтра игроков добавляется сущность `filter_activator_name`, а в `trigger_multiple` прописывается `"filtername"`.

### `logic_auto`

* Автозапуск логики карты. Содержит события `OnMapSpawn`, `OnNewGame`, `OnMultiNewRound`.
* Часто используется для стартовой настройки света, дверей и пр.

### `info_player_start`

* Базовая точка появления игрока.
* Обязательна для компиляции одиночных карт; без неё игрок заспавнится в `0 0 0` и может застрять.

### `func_detail`

* Brush entity, которую `vbsp` исключает из расчёта BSP-разделения.
* Внутри VMF выглядит как обычный `entity` с `classname` = `func_detail` и набором `solid`.
* Используйте для мелких выступов, которые не должны делить пространство.

## 19. Настройка освещения в VMF

* Глобальное освещение задаётся через `light_environment` (entity).
* Значение `_ambient` формирует фон, `_light` — направление и цвет солнца.
* `env_sun` добавляет солнечный эффект в небе.
* Для мягкого света используйте множество `light` с небольшими радиусами и настройками `linear`/`quadratic` затухания.

### Цветовое пространство и числа

* Цвета задаются целыми значениями 0–255. Прозрачность (четвёртое число в `_light`) — интенсивность.
* Отрицательные значения в `_light` включают специальный режим «чёрного света» (редко используется, но возможен).
* Для холодного оттенка увеличьте значение синего канала, для тёплого — красного/зелёного.

## 20. Ссылки на Valve Developer Community

Valve поддерживает официальный вики-ресурс, где каждая сущность и аспект VMF подробно описаны. Рекомендуемые страницы:

* [Valve Developer Community — VMF](https://developer.valvesoftware.com/wiki/Valve_Map_Format)
* [Hammer Manual](https://developer.valvesoftware.com/wiki/Hammer_Manual)
* [Brush](https://developer.valvesoftware.com/wiki/Brush)
* [Displacement](https://developer.valvesoftware.com/wiki/Displacement)
* [Source Engine Level Design](https://developer.valvesoftware.com/wiki/Category:Level_Design)

Эти ресурсы можно использовать как дополнение к текущему документу.

---

Помните: VMF — это «скелет» карты. Понимание, как он устроен, позволяет:

* Делать автоматические скрипты генерации уровней.
* Ищать и исправлять ошибки компиляции.
* Работать в команде, согласовывая стили и соглашения.

## 21. Пример полного блока `entity`

Ниже пример `func_door`, собранный из кисти и логики:

```
entity
{
    "id" "512"
    "classname" "func_door"
    "targetname" "main_door"
    "origin" "128 256 64"
    "spawnflags" "32"
    "speed" "200"
    connections
    {
        "OnClose" "light_door,TurnOff,,0,-1"
        "OnOpen" "ambient_door,PlaySound,,0,-1"
    }
    solid
    {
        "id" "513"
        side { ... }
        side { ... }
        editor
        {
            "color" "255 200 0"
            "groupid" "7"
        }
    }
    editor
    {
        "color" "255 255 255"
        "visgroupid" "2"
    }
}
```

Такой пример наглядно показывает вложенность: сущность содержит собственные `solid`, связи и редакторские настройки. Если вручную редактировать координаты граней, не забудьте обновить все три точки в `plane`.

Не бойтесь открывать `.vmf` и смотреть, как Hammer записал ваш уровень. Чем лучше вы понимаете структуру файла, тем легче контролировать поведение карты при компиляции и в игре.
